/**
 * 202.快乐数
 */
class Question202 {

    /**
     * 【最优解】快慢指针。
     * 通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。
     * 起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。
     * 意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。
     * 因此我们在这里可以使用【弗洛伊德循环查找算法】。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。
     * 不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。
     * 我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。
     * 如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。
     * 如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。
     * 
     * 【Tips】为什么环状链表兔子和乌龟一定会遇上，可以这样想想：
     * 1.如果兔子在乌龟后面1个节点（紧紧相邻），则下一次移动后两者就能相遇。
     * 2.如果兔子在乌龟后面2个节点（中间隔1点），则下一次移动后变成情况1紧紧相邻。
     * 3.如果兔子在乌龟后面3个节点（中间隔2点），则下一次移动后变成情况2仅隔1点。
     * 4.以此类推。
     */
    public boolean isHappy(int n) {
        int slow = n;
        int fast = getNext(n);
        while (fast != 1 && fast != slow) {
            //乌龟每次动1格
            slow = getNext(slow);
            //兔子每次动2格
            fast = getNext(getNext(fast));
        }
        return fast == 1;
    }

    private int getNext(int n) {
        int result = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            result += d * d;
        }
        return result;
    }
}